## 비관적인 방법

현재 수정하려는 데이터가 언제든 다른 요청에 의해 수정될 가능성을 고려하여

해당 데이터에 lock을 거는 방식입니다

장점은 데이터의 무결성을 완벽히 지킬 수 있습니다.

수정할 데이터에 row level lock을 걸기 때문에 다른 요청에서 수정하는 것이 불가능합니다.

단점은 lock으로 인하여 이후의 다른 요청은 대기상태로 빠집니다

기존의 lock의 transaction이 commit 또는 rollback으로 끝나면 대기하고 있던 요청을 비로소 실행

해당 방법은 서버의 성능에 따라 처리량이 결정되므로 

도입하기전 서비스의 최소처리 tps에 부합하는지 확인해야합니다 

### lock을 거는 방법 3가지

1) DB에서 제공하는 데이터 Lock 수준 높이기

일반적인 기본수준값 Repeatable Read를 Serializer 이상의 수준으로 올리기

강도 높은 락으로 완전한 일관성 유지가능

하지만 이로 인한 다른 요청들이 모두 취소됨

취소된 작업들은 재시도를 위한 처리가 반드시 필요하므로 서비스에 적용하는 것에 현실성이 부족 

2) select for update 를 활용하여 명시적으로 lock을 잡을 수 있음

하지만 lock을 잡는 구간이 길어져 성능에 심각한 영향을 끼침

극장예매와 같은 서비스가 아니라면 사용하지 않는 것이 좋음

3) Data의 transaction의 write lock 활용

일반적으로 데이터를 수정할 때 write lock이 걸리고 transaction이 끝나야 lock이 풀리는 것을 이용

데이터의 일관성을 유지할 수 있지만 DB와 서버 성능에 다라 서비스 속도가 좌우됨 

## 낙관적인 방법

수정하려는 데이터는 나만 수정할 것이라는 낙관적인 생각의 방법 

테이블에 version or update_at이라는 시간컬럼을 만들어서

수정될때마다 1씩 증가하거나 현재시간으로 갱신하게 해줌

값을 수정할때 version이 동일하면 수정가능 그렇지 않으면 실패 

단점은 두개의 db세션이 동일한 버전으로 수정하려고 하면 한개의 세션에선 version conflict이 발생하여

affected row count가 0이됨

따라서 이 경우 요청을 재시도하도록 구현필요
